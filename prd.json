[
  {
    "category": "technical",
    "description": "Mejorar manejo de errores en todos los analizadores con mensajes más descriptivos y códigos de error específicos",
    "steps": [
      "Revisar todos los analizadores (RouteAnalyzer, FormRequestAnalyzer, ResourceAnalyzer)",
      "Identificar puntos donde se lanzan excepciones genéricas",
      "Crear excepciones personalizadas con códigos de error específicos",
      "Agregar mensajes descriptivos que incluyan contexto y sugerencias",
      "Actualizar manejo de errores en GenerateApiContractCommand",
      "Probar con rutas inválidas y verificar mensajes de error claros",
      "Verificar que los códigos de error son únicos y descriptivos"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Implementar sistema de caché para resultados de análisis de recursos y rutas para mejorar rendimiento",
    "steps": [
      "Crear servicio de caché para almacenar resultados de análisis",
      "Implementar caché en RouteAnalyzer para rutas analizadas",
      "Implementar caché en ResourceAnalyzer para schemas generados",
      "Implementar caché en FormRequestAnalyzer para reglas parseadas",
      "Agregar invalidación de caché cuando cambian archivos relevantes",
      "Agregar comando para limpiar caché (php artisan mcp-tools:clear-cache)",
      "Probar rendimiento antes y después de implementar caché",
      "Verificar que el caché se invalida correctamente al modificar código"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Extender soporte de autenticación para detectar más tipos (Passport, JWT, API keys, etc.)",
    "steps": [
      "Revisar método determineAuth en RouteAnalyzer",
      "Agregar detección de Laravel Passport (passport middleware)",
      "Agregar detección de JWT (tymon/jwt-auth)",
      "Agregar detección de API keys (custom middleware)",
      "Agregar detección de OAuth2",
      "Actualizar tests para verificar detección de cada tipo",
      "Verificar que el contrato generado incluye el tipo correcto de auth",
      "Probar con rutas que usan diferentes tipos de autenticación"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Crear nueva herramienta MCP para validar que el contrato de API está actualizado con las rutas",
    "steps": [
      "Crear nueva clase ValidateApiContract en src/Tools/",
      "Implementar lógica para comparar rutas actuales con contrato",
      "Detectar rutas nuevas no documentadas",
      "Detectar rutas eliminadas del código pero presentes en contrato",
      "Detectar cambios en métodos HTTP",
      "Retornar reporte de validación con diferencias encontradas",
      "Registrar herramienta en MCP server",
      "Probar con contrato desactualizado y verificar detección de diferencias",
      "Probar con contrato actualizado y verificar que no hay diferencias"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Crear herramienta MCP para comparar dos versiones de contratos de API y detectar cambios",
    "steps": [
      "Crear nueva clase CompareApiContracts en src/Tools/",
      "Implementar lógica para cargar dos archivos de contrato",
      "Comparar rutas entre versiones (agregadas, eliminadas, modificadas)",
      "Detectar cambios en schemas de request/response",
      "Detectar cambios en autenticación",
      "Detectar cambios en parámetros de ruta",
      "Generar reporte de diferencias estructurado",
      "Registrar herramienta en MCP server",
      "Probar comparando dos versiones diferentes de contrato",
      "Verificar que el reporte muestra todos los cambios relevantes"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Extraer y usar PHPDoc de métodos de controlador para mejorar descripciones de rutas",
    "steps": [
      "Crear extractor de PHPDoc en RouteAnalyzer",
      "Analizar comentarios PHPDoc de métodos de controlador",
      "Extraer descripción del método desde @param y comentarios",
      "Extraer información de parámetros desde @param tags",
      "Extraer información de retorno desde @return tags",
      "Incluir descripciones extraídas en el contrato generado",
      "Probar con controladores que tienen PHPDoc completo",
      "Verificar que las descripciones aparecen en describe-api-route",
      "Probar con controladores sin PHPDoc y verificar fallback"
    ],
    "passes": false
  },
  {
    "category": "functional",
    "description": "Agregar comando para exportar contrato de API a formato OpenAPI/Swagger",
    "steps": [
      "Crear comando ExportOpenApiCommand",
      "Implementar conversión de contrato JSON a formato OpenAPI 3.0",
      "Mapear rutas a paths de OpenAPI",
      "Convertir schemas a schemas de OpenAPI",
      "Incluir información de autenticación en security schemes",
      "Generar archivo YAML o JSON de OpenAPI",
      "Probar exportación de contrato completo",
      "Validar que el archivo generado es OpenAPI válido",
      "Probar importación del archivo en Swagger UI"
    ],
    "passes": false
  },
  {
    "category": "technical",
    "description": "Mejorar detección de rate limits para extraer valores reales de configuración de Laravel",
    "steps": [
      "Revisar método extractRateLimit en RouteAnalyzer",
      "Analizar configuración de rate limits en config/throttle.php o RouteServiceProvider",
      "Extraer valores reales (requests per minute) desde configuración",
      "Detectar rate limits dinámicos desde middleware parameters",
      "Incluir valores exactos en el contrato generado",
      "Probar con diferentes configuraciones de rate limit",
      "Verificar que los valores aparecen correctamente en describe-api-route"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Mejorar análisis de parámetros de consulta desde controladores sin FormRequest",
    "steps": [
      "Revisar FormRequestAnalyzer para casos sin FormRequest",
      "Analizar tipo hints de parámetros en métodos de controlador",
      "Analizar Request::input() o Request::get() en código del método",
      "Extraer parámetros de consulta desde comentarios PHPDoc",
      "Inferir tipos desde uso en el código",
      "Incluir parámetros detectados en request_schema",
      "Probar con controladores que usan Request directamente",
      "Verificar que los parámetros aparecen en el contrato"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Generar ejemplos de respuestas basados en schemas de recursos",
    "steps": [
      "Crear generador de ejemplos en ResourceAnalyzer",
      "Usar datos de factory para generar ejemplos realistas",
      "Generar ejemplos para campos string, integer, boolean, etc.",
      "Generar ejemplos para arrays y objetos anidados",
      "Incluir ejemplos en response_schema del contrato",
      "Probar generación de ejemplos para diferentes tipos de recursos",
      "Verificar que los ejemplos son válidos según el schema",
      "Incluir ejemplos en describe-api-route"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Optimizar escaneo de recursos usando índices y caché de metadatos",
    "steps": [
      "Revisar método preloadResources en ResourceAnalyzer",
      "Crear índice de recursos con metadatos (nombre, namespace, path)",
      "Implementar caché de metadatos de recursos",
      "Optimizar búsqueda de recursos usando el índice",
      "Reducir escaneo de archivos en cada ejecución",
      "Probar rendimiento con proyectos grandes (100+ recursos)",
      "Verificar que la funcionalidad se mantiene igual",
      "Medir mejora en tiempo de ejecución"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Agregar soporte para operaciones batch en herramientas MCP (múltiples rutas a la vez)",
    "steps": [
      "Modificar ListApiRoutes para aceptar array de filtros",
      "Modificar DescribeApiRoute para aceptar array de paths",
      "Implementar procesamiento paralelo cuando sea posible",
      "Retornar resultados agrupados por operación",
      "Actualizar schemas de herramientas MCP",
      "Probar list-api-routes con múltiples filtros simultáneos",
      "Probar describe-api-route con múltiples paths",
      "Verificar que los resultados son correctos"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Mejorar algoritmo de búsqueda en list-api-routes para búsqueda full-text más inteligente",
    "steps": [
      "Revisar método matchesSearch en ListApiRoutes",
      "Implementar búsqueda fuzzy para tolerar typos",
      "Agregar búsqueda por relevancia (ranking de resultados)",
      "Mejorar búsqueda en descripciones y schemas",
      "Agregar soporte para búsqueda con operadores (AND, OR)",
      "Probar búsqueda con términos parciales",
      "Probar búsqueda con typos",
      "Verificar que los resultados más relevantes aparecen primero"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Agregar agrupación de rutas por controlador o prefijo en list-api-routes",
    "steps": [
      "Agregar parámetro group_by en ListApiRoutes",
      "Implementar agrupación por controlador",
      "Implementar agrupación por prefijo de ruta",
      "Implementar agrupación por versión de API",
      "Retornar resultados agrupados en estructura jerárquica",
      "Actualizar schema de la herramienta MCP",
      "Probar agrupación por controlador",
      "Probar agrupación por prefijo",
      "Verificar que la estructura de agrupación es clara"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Extraer descripciones de rutas desde comentarios PHPDoc en controladores",
    "steps": [
      "Implementar parser de PHPDoc en RouteAnalyzer",
      "Extraer descripción principal del método desde primer párrafo del PHPDoc",
      "Extraer descripción desde @description tag si existe",
      "Incluir descripciones en el contrato generado",
      "Incluir descripciones en describe-api-route",
      "Probar con métodos que tienen PHPDoc descriptivo",
      "Verificar que las descripciones aparecen correctamente",
      "Probar con métodos sin PHPDoc y verificar que no falla"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Mejorar detección de tipos de parámetros de ruta usando route model binding",
    "steps": [
      "Revisar extractPathParams en RouteAnalyzer",
      "Analizar route model binding en controladores",
      "Detectar tipo del modelo desde type hint del método",
      "Inferir tipo desde nombre del parámetro (User -> integer)",
      "Incluir tipo detectado en path_parameters del contrato",
      "Probar con diferentes tipos de route model binding",
      "Verificar que los tipos aparecen correctamente en el contrato",
      "Probar con parámetros sin type hint y verificar fallback"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Agregar análisis detallado de middleware aplicado a cada ruta",
    "steps": [
      "Extender RouteAnalyzer para analizar todos los middleware",
      "Extraer nombres de middleware aplicados",
      "Categorizar middleware (auth, throttle, validate, etc.)",
      "Extraer parámetros de middleware cuando sea posible",
      "Incluir información de middleware en el contrato",
      "Incluir middleware en describe-api-route",
      "Probar con rutas que tienen múltiples middleware",
      "Verificar que todos los middleware se detectan correctamente"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Agregar soporte para marcar rutas como deprecadas en el contrato",
    "steps": [
      "Detectar @deprecated tag en PHPDoc de métodos",
      "Detectar atributo #[Deprecated] en PHP 8",
      "Extraer mensaje de deprecación si está disponible",
      "Incluir flag deprecated en el contrato generado",
      "Incluir información de deprecación en describe-api-route",
      "Probar con métodos marcados como deprecated",
      "Verificar que la información aparece en el contrato",
      "Probar con métodos sin deprecación y verificar que no aparece"
    ],
    "passes": true
  },
  {
    "category": "validation",
    "description": "Mejorar análisis de reglas de validación para arrays anidados y estructuras complejas",
    "steps": [
      "Revisar parseValidationRules en FormRequestAnalyzer",
      "Mejorar parsing de reglas para arrays anidados (nested.*.field)",
      "Soporte para estructuras de validación complejas",
      "Detectar tipos de elementos en arrays",
      "Mantener estructura jerárquica en schema generado",
      "Probar con FormRequests que tienen arrays anidados",
      "Verificar que la estructura se mantiene en el schema",
      "Probar con múltiples niveles de anidamiento"
    ],
    "passes": true
  },
  {
    "category": "validation",
    "description": "Soporte para reglas de validación personalizadas de Laravel",
    "steps": [
      "Identificar reglas personalizadas en FormRequests",
      "Extraer nombre de la regla personalizada",
      "Incluir regla personalizada en constraints del schema",
      "Documentar que es una regla personalizada",
      "Probar con FormRequests que usan reglas personalizadas",
      "Verificar que las reglas aparecen en el contrato",
      "Probar con diferentes tipos de reglas personalizadas"
    ],
    "passes": true
  },
  {
    "category": "validation",
    "description": "Soporte para reglas de validación condicionales (sometimes, required_if, etc.)",
    "steps": [
      "Revisar parseValidationRules para reglas condicionales",
      "Detectar regla 'sometimes' y marcar campo como opcional condicional",
      "Detectar 'required_if', 'required_unless', etc.",
      "Extraer condiciones de las reglas",
      "Incluir información de condiciones en el schema",
      "Probar con FormRequests que usan reglas condicionales",
      "Verificar que las condiciones se documentan correctamente",
      "Probar con múltiples reglas condicionales en un campo"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Mejorar descubrimiento de recursos usando análisis estático más robusto",
    "steps": [
      "Revisar métodos de descubrimiento en ResourceAnalyzer",
      "Mejorar análisis estático de código para detectar recursos",
      "Usar AST para análisis más preciso",
      "Mejorar resolución de nombres de clases",
      "Reducir dependencia de factories para descubrimiento",
      "Probar descubrimiento en proyectos grandes",
      "Verificar que se encuentran todos los recursos",
      "Medir mejora en precisión de descubrimiento"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Detectar y documentar relaciones entre recursos (nested resources)",
    "steps": [
      "Analizar uso de recursos anidados en código",
      "Detectar cuando un Resource incluye otro Resource",
      "Extraer información de relaciones (hasMany, belongsTo, etc.)",
      "Incluir información de relaciones en response_schema",
      "Documentar recursos relacionados en el contrato",
      "Probar con recursos que tienen relaciones",
      "Verificar que las relaciones se documentan correctamente",
      "Probar con múltiples niveles de anidamiento"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Optimizar parsing de AST para análisis de código más rápido",
    "steps": [
      "Revisar uso de AST en ResourceAnalyzer",
      "Implementar caché de AST parseado",
      "Optimizar queries de AST para reducir tiempo",
      "Usar NodeFinder de manera más eficiente",
      "Reducir número de pasadas sobre el AST",
      "Probar rendimiento con archivos grandes",
      "Verificar que la funcionalidad se mantiene",
      "Medir mejora en tiempo de análisis"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Soporte para actualizaciones incrementales del contrato (solo rutas modificadas)",
    "steps": [
      "Agregar opción --incremental al comando generate-contract",
      "Implementar detección de archivos modificados",
      "Comparar timestamps de archivos con contrato existente",
      "Actualizar solo rutas modificadas en el contrato",
      "Mantener rutas no modificadas sin cambios",
      "Probar con modificaciones en un controlador",
      "Verificar que solo se actualiza lo necesario",
      "Probar con eliminación de rutas"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Soporte para versionado de contratos de API con historial",
    "steps": [
      "Crear sistema de versionado de contratos",
      "Almacenar versiones anteriores en storage/api-contracts/versions/",
      "Agregar comando para listar versiones (php artisan mcp-tools:versions)",
      "Agregar comando para restaurar versión (php artisan mcp-tools:restore)",
      "Incluir metadata de versión en contrato (timestamp, git commit, etc.)",
      "Probar generación de múltiples versiones",
      "Verificar que se pueden listar versiones",
      "Probar restauración de versión anterior"
    ],
    "passes": true
  },
  {
    "category": "validation",
    "description": "Validar configuración del paquete al iniciar con mensajes de error claros",
    "steps": [
      "Crear validador de configuración en McpToolsServiceProvider",
      "Validar que las rutas de configuración existen",
      "Validar que los namespaces son válidos",
      "Validar permisos de escritura en contract_path",
      "Mostrar mensajes de error claros si hay problemas",
      "Probar con configuración inválida",
      "Verificar que los mensajes son claros y accionables",
      "Probar con configuración válida y verificar que no hay errores"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Agregar comando de health check para verificar estado del contrato y herramientas",
    "steps": [
      "Crear comando HealthCheckCommand",
      "Verificar que el contrato existe y es válido",
      "Verificar que las herramientas MCP están registradas",
      "Verificar que los analizadores pueden funcionar",
      "Verificar que las rutas de configuración son accesibles",
      "Retornar código de salida apropiado (0 = OK, 1 = error)",
      "Probar con sistema saludable",
      "Probar con problemas (contrato faltante, herramientas no registradas)",
      "Verificar que el comando detecta todos los problemas"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Agregar comando para mostrar métricas del contrato (número de rutas, cobertura, etc.)",
    "steps": [
      "Crear comando MetricsCommand",
      "Contar total de rutas en el contrato",
      "Contar rutas por método HTTP",
      "Contar rutas por versión de API",
      "Calcular porcentaje de rutas con schemas completos",
      "Mostrar estadísticas de autenticación",
      "Mostrar estadísticas de rate limits",
      "Probar con contrato existente",
      "Verificar que las métricas son correctas"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Mejorar todos los mensajes de error con sugerencias de solución",
    "steps": [
      "Revisar todos los mensajes de error en el paquete",
      "Agregar sugerencias específicas a cada mensaje",
      "Incluir comandos sugeridos cuando sea apropiado",
      "Incluir enlaces a documentación cuando sea relevante",
      "Probar cada tipo de error",
      "Verificar que las sugerencias son útiles",
      "Asegurar que los mensajes son claros y accionables"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Agregar logging opcional para debugging de análisis",
    "steps": [
      "Agregar configuración para habilitar logging",
      "Implementar logging en puntos clave de análisis",
      "Loggear inicio y fin de análisis de cada ruta",
      "Loggear errores y advertencias",
      "Loggear información de rendimiento",
      "Agregar comando para ver logs (php artisan mcp-tools:logs)",
      "Probar con logging habilitado",
      "Verificar que los logs son útiles para debugging"
    ],
    "passes": true
  },
  {
    "category": "ui",
    "description": "Mejorar indicador de progreso en comando de generación con barra de progreso",
    "steps": [
      "Revisar GenerateApiContractCommand",
      "Implementar barra de progreso usando Symfony ProgressBar",
      "Mostrar progreso durante análisis de rutas",
      "Mostrar tiempo estimado restante",
      "Mostrar ruta actual siendo procesada",
      "Probar con proyecto grande (100+ rutas)",
      "Verificar que la barra de progreso funciona correctamente",
      "Verificar que no afecta el rendimiento"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Agregar modo dry-run al comando de generación para validar sin escribir archivo",
    "steps": [
      "Agregar opción --dry-run al comando generate-contract",
      "Ejecutar todo el análisis sin escribir el archivo",
      "Mostrar resumen de lo que se generaría",
      "Mostrar errores y advertencias encontrados",
      "Retornar código de salida apropiado",
      "Probar con --dry-run y verificar que no se escribe archivo",
      "Verificar que el resumen es correcto",
      "Probar con errores y verificar que se detectan"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Agregar filtro por controlador en list-api-routes",
    "steps": [
      "Agregar parámetro controller en schema de ListApiRoutes",
      "Extraer nombre de controlador desde action de ruta",
      "Filtrar rutas por controlador especificado",
      "Soportar búsqueda parcial de nombre de controlador",
      "Actualizar documentación de la herramienta",
      "Probar filtrado por controlador exacto",
      "Probar filtrado por nombre parcial",
      "Verificar que los resultados son correctos"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Agregar filtro por resource usado en list-api-routes",
    "steps": [
      "Agregar parámetro resource en schema de ListApiRoutes",
      "Detectar qué Resource se usa en cada ruta",
      "Filtrar rutas por Resource especificado",
      "Soportar búsqueda parcial de nombre de Resource",
      "Actualizar documentación de la herramienta",
      "Probar filtrado por Resource exacto",
      "Probar filtrado por nombre parcial",
      "Verificar que los resultados son correctos"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Agregar opciones de ordenamiento en list-api-routes (por path, method, version)",
    "steps": [
      "Agregar parámetro sort en schema de ListApiRoutes",
      "Implementar ordenamiento por path (asc/desc)",
      "Implementar ordenamiento por method",
      "Implementar ordenamiento por version",
      "Soportar ordenamiento múltiple (sort=path,method)",
      "Actualizar documentación de la herramienta",
      "Probar cada tipo de ordenamiento",
      "Probar ordenamiento múltiple",
      "Verificar que los resultados están ordenados correctamente"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Mejorar información de paginación con enlaces y metadatos adicionales",
    "steps": [
      "Revisar respuesta de paginación en ListApiRoutes",
      "Agregar enlaces first, last, prev, next",
      "Agregar información de página actual y total",
      "Agregar información de límite y offset",
      "Incluir información de total de resultados",
      "Probar paginación con diferentes límites",
      "Verificar que los enlaces son correctos",
      "Probar navegación entre páginas"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Agregar estadísticas de rutas en respuesta de list-api-routes (total por método, versión, etc.)",
    "steps": [
      "Agregar sección statistics en respuesta de ListApiRoutes",
      "Calcular total de rutas por método HTTP",
      "Calcular total de rutas por versión de API",
      "Calcular total de rutas con/sin autenticación",
      "Calcular total de rutas con/sin schemas",
      "Incluir estadísticas en respuesta JSON",
      "Probar con diferentes filtros",
      "Verificar que las estadísticas son correctas"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Mejorar matching de rutas con parámetros usando regex más robusto",
    "steps": [
      "Revisar método matchesRoutePattern en DescribeApiRoute",
      "Mejorar regex para manejar parámetros opcionales",
      "Soportar múltiples parámetros en ruta",
      "Soportar parámetros con constraints (where)",
      "Manejar edge cases (rutas con guiones, puntos, etc.)",
      "Probar con diferentes patrones de rutas",
      "Verificar que el matching es correcto",
      "Probar casos edge y verificar que no fallan"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Soporte para rutas con nombres y aliases en el contrato",
    "steps": [
      "Extraer nombre de ruta desde Route::getName()",
      "Incluir nombre de ruta en el contrato generado",
      "Incluir nombre de ruta en describe-api-route",
      "Soportar búsqueda por nombre de ruta en list-api-routes",
      "Probar con rutas nombradas",
      "Verificar que los nombres aparecen en el contrato",
      "Probar búsqueda por nombre de ruta"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Detectar y documentar códigos de estado HTTP posibles para cada ruta",
    "steps": [
      "Analizar código de controladores para detectar códigos de estado",
      "Detectar return response()->json(..., 201)",
      "Detectar return abort(404)",
      "Detectar códigos desde Resource responses",
      "Incluir códigos de estado posibles en el contrato",
      "Incluir códigos de estado en describe-api-route",
      "Probar con diferentes tipos de respuestas",
      "Verificar que los códigos se detectan correctamente"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Detectar y documentar headers requeridos desde middleware",
    "steps": [
      "Extender análisis de middleware en RouteAnalyzer",
      "Detectar headers requeridos desde middleware custom",
      "Detectar headers desde CORS middleware",
      "Detectar headers desde rate limiting",
      "Incluir headers requeridos en el contrato",
      "Incluir headers en describe-api-route",
      "Probar con diferentes tipos de middleware",
      "Verificar que los headers se detectan correctamente"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Documentar headers de respuesta comunes (Content-Type, etc.)",
    "steps": [
      "Analizar tipos de respuesta de cada ruta",
      "Detectar Content-Type desde tipo de Resource",
      "Incluir headers comunes en response_schema",
      "Documentar headers estándar (Content-Type, X-RateLimit, etc.)",
      "Incluir headers en describe-api-route",
      "Probar con diferentes tipos de respuesta",
      "Verificar que los headers se documentan correctamente"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Soporte para content negotiation (Accept headers)",
    "steps": [
      "Detectar soporte para diferentes formatos de respuesta",
      "Analizar Accept headers en middleware",
      "Documentar formatos soportados (JSON, XML, etc.)",
      "Incluir información de content negotiation en contrato",
      "Incluir en describe-api-route",
      "Probar con APIs que soportan múltiples formatos",
      "Verificar que la información es correcta"
    ],
    "passes": true
  },
  {
    "category": "validation",
    "description": "Mejorar detección de tipos en schemas (nullable, union types, etc.)",
    "steps": [
      "Revisar detección de tipos en FormRequestAnalyzer y ResourceAnalyzer",
      "Detectar tipos nullable desde type hints (?string, string|null)",
      "Detectar union types (string|int)",
      "Detectar tipos desde PHPDoc (@var string|null)",
      "Incluir información de nullable en schemas",
      "Probar con diferentes tipos de type hints",
      "Verificar que los tipos se detectan correctamente",
      "Probar con tipos complejos"
    ],
    "passes": true
  },
  {
    "category": "validation",
    "description": "Soporte completo para enums de PHP en schemas",
    "steps": [
      "Detectar uso de enums en type hints",
      "Extraer valores posibles del enum",
      "Incluir enum values en schema generado",
      "Soportar backed enums (string, int)",
      "Incluir información de enum en describe-api-route",
      "Probar con diferentes tipos de enums",
      "Verificar que los valores se extraen correctamente",
      "Probar con enums anidados en arrays"
    ],
    "passes": true
  },
  {
    "category": "validation",
    "description": "Detectar y documentar formatos de fecha usados en validación",
    "steps": [
      "Detectar reglas de validación de fecha (date, date_format)",
      "Extraer formato desde date_format:Y-m-d",
      "Incluir formato en schema generado",
      "Documentar formato en describe-api-route",
      "Probar con diferentes formatos de fecha",
      "Verificar que los formatos se detectan correctamente",
      "Probar con formatos personalizados"
    ],
    "passes": true
  },
  {
    "category": "validation",
    "description": "Soporte para detección de uploads de archivos en FormRequests",
    "steps": [
      "Detectar reglas file, image, mimes en validación",
      "Extraer tipos MIME permitidos",
      "Extraer tamaño máximo de archivo",
      "Incluir información de upload en request_schema",
      "Marcar campo como tipo file en schema",
      "Probar con FormRequests que validan archivos",
      "Verificar que la información se incluye correctamente",
      "Probar con múltiples campos de archivo"
    ],
    "passes": true
  },
  {
    "category": "validation",
    "description": "Validar que los schemas generados son JSON Schema válidos",
    "steps": [
      "Crear validador de JSON Schema",
      "Validar cada schema generado contra JSON Schema draft",
      "Detectar y reportar errores de validación",
      "Incluir validación en comando generate-contract",
      "Agregar opción --validate-schemas",
      "Probar con schemas válidos",
      "Probar con schemas inválidos y verificar detección",
      "Incluir errores en reporte de generación"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Generar ejemplos de valores para cada campo en schemas",
    "steps": [
      "Crear generador de ejemplos para cada tipo de dato",
      "Generar ejemplos realistas (emails válidos, URLs, etc.)",
      "Generar ejemplos para campos con constraints (min, max, enum)",
      "Incluir ejemplos en request_schema y response_schema",
      "Incluir ejemplos en describe-api-route",
      "Probar generación de ejemplos para diferentes tipos",
      "Verificar que los ejemplos son válidos según el schema",
      "Probar con schemas complejos"
    ],
    "passes": true
  },
  {
    "category": "validation",
    "description": "Mejorar análisis de estructuras anidadas en FormRequests",
    "steps": [
      "Revisar parseValidationRules para estructuras anidadas",
      "Mejorar soporte para arrays de objetos",
      "Soporte para objetos anidados múltiples niveles",
      "Mantener estructura jerárquica completa en schema",
      "Probar con FormRequests complejos",
      "Verificar que la estructura se mantiene",
      "Probar con diferentes niveles de anidamiento"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Sistema extensible para transformadores de schema personalizados",
    "steps": [
      "Crear interfaz SchemaTransformerInterface",
      "Crear sistema de registro de transformadores",
      "Permitir registrar transformadores personalizados",
      "Aplicar transformadores durante generación de schema",
      "Documentar cómo crear transformadores personalizados",
      "Crear ejemplo de transformador personalizado",
      "Probar con transformador personalizado",
      "Verificar que los transformadores se aplican correctamente"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Implementar caché para schemas de recursos generados",
    "steps": [
      "Crear sistema de caché específico para schemas de recursos",
      "Usar hash del código del Resource como clave de caché",
      "Invalidar caché cuando cambia el archivo del Resource",
      "Implementar caché en simulateResourceOutput",
      "Probar con múltiples llamadas al mismo Resource",
      "Verificar que el caché mejora el rendimiento",
      "Probar invalidación de caché"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Mejorar fallback cuando factories no están disponibles",
    "steps": [
      "Revisar fallback en ResourceAnalyzer cuando factory falla",
      "Crear instancias de modelo con datos mínimos",
      "Usar reflection para crear modelos sin factory",
      "Mejorar mensajes de error cuando fallback falla",
      "Probar con modelos sin factory",
      "Verificar que el fallback funciona",
      "Probar con modelos que requieren dependencias"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Mejorar detección de modelos desde nombres de recursos",
    "steps": [
      "Revisar lógica de detección de modelos en ResourceAnalyzer",
      "Mejorar mapeo de nombres de Resource a Model",
      "Soportar diferentes convenciones de nombres",
      "Buscar en múltiples namespaces si es necesario",
      "Probar con diferentes convenciones de nombres",
      "Verificar que los modelos se detectan correctamente",
      "Probar con recursos en subdirectorios"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Soporte para recursos que extienden otros recursos",
    "steps": [
      "Detectar herencia de recursos usando reflection",
      "Extraer campos del recurso padre",
      "Combinar campos del padre e hijo en schema",
      "Manejar múltiples niveles de herencia",
      "Incluir información de herencia en schema",
      "Probar con recursos que extienden otros",
      "Verificar que los campos del padre se incluyen",
      "Probar con múltiples niveles de herencia"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Mejor detección de paginación en resource collections",
    "steps": [
      "Mejorar detección de paginación en ResourceAnalyzer",
      "Detectar LengthAwarePaginator en código",
      "Detectar paginación desde tipo de retorno",
      "Incluir estructura de paginación en response_schema",
      "Documentar campos de paginación (data, links, meta)",
      "Probar con diferentes tipos de paginación",
      "Verificar que la estructura de paginación es correcta"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Detectar campos condicionales en recursos (when, whenLoaded)",
    "steps": [
      "Analizar código de recursos para detectar when() y whenLoaded()",
      "Extraer condiciones de campos condicionales",
      "Documentar campos condicionales en schema",
      "Incluir información de cuándo aparecen los campos",
      "Probar con recursos que usan when/whenLoaded",
      "Verificar que los campos condicionales se documentan",
      "Probar con múltiples campos condicionales"
    ],
    "passes": true
  },
  {
    "category": "functional",
    "description": "Extraer metadatos adicionales de recursos (with, additional)",
    "steps": [
      "Analizar uso de with() y additional() en recursos",
      "Extraer metadatos adicionales",
      "Incluir metadatos en response_schema",
      "Documentar estructura de metadatos",
      "Probar con recursos que usan with/additional",
      "Verificar que los metadatos se extraen correctamente",
      "Probar con diferentes tipos de metadatos"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Crear tests unitarios completos para todos los analizadores",
    "steps": [
      "Crear tests para RouteAnalyzer",
      "Crear tests para FormRequestAnalyzer",
      "Crear tests para ResourceAnalyzer",
      "Cubrir todos los métodos públicos",
      "Probar casos edge y errores",
      "Ejecutar tests y verificar que pasan",
      "Verificar cobertura de código mínima 80%"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Crear tests de integración para herramientas MCP",
    "steps": [
      "Crear tests para ListApiRoutes",
      "Crear tests para DescribeApiRoute",
      "Probar con contratos reales",
      "Probar con diferentes filtros y parámetros",
      "Probar casos edge (rutas no encontradas, etc.)",
      "Ejecutar tests y verificar que pasan",
      "Verificar que las herramientas funcionan correctamente"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Crear tests para comando de generación de contrato",
    "steps": [
      "Crear tests para GenerateApiContractCommand",
      "Probar generación de contrato completo",
      "Probar con opciones --strict y --detailed",
      "Probar manejo de errores",
      "Probar con diferentes configuraciones",
      "Ejecutar tests y verificar que pasan",
      "Verificar que el contrato generado es correcto"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Agregar tests para casos edge (rutas sin controlador, recursos sin factory, etc.)",
    "steps": [
      "Identificar casos edge en el código",
      "Crear tests para rutas sin controlador",
      "Crear tests para recursos sin factory",
      "Crear tests para FormRequests con dependencias complejas",
      "Crear tests para rutas con middleware complejo",
      "Ejecutar tests y verificar que pasan",
      "Verificar que los casos edge se manejan correctamente"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Agregar tests de rendimiento para análisis de grandes codebases",
    "steps": [
      "Crear tests de rendimiento",
      "Probar con codebase grande (500+ rutas)",
      "Medir tiempo de generación de contrato",
      "Medir tiempo de análisis de recursos",
      "Establecer benchmarks de rendimiento",
      "Ejecutar tests y verificar que cumplen benchmarks",
      "Documentar resultados de rendimiento"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Usar mocks en tests para evitar dependencias de factories reales",
    "steps": [
      "Revisar tests existentes",
      "Identificar dependencias de factories reales",
      "Crear mocks para modelos y recursos",
      "Reemplazar factories con mocks donde sea apropiado",
      "Mantener algunos tests con factories para integración",
      "Ejecutar tests y verificar que pasan",
      "Verificar que los tests son más rápidos"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Crear fixtures de prueba para diferentes escenarios de rutas y recursos",
    "steps": [
      "Crear directorio tests/Fixtures/",
      "Crear fixtures para diferentes tipos de rutas",
      "Crear fixtures para diferentes tipos de recursos",
      "Crear fixtures para diferentes tipos de FormRequests",
      "Usar fixtures en tests",
      "Ejecutar tests y verificar que pasan",
      "Documentar cómo usar las fixtures"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Aumentar cobertura de tests a mínimo 80%",
    "steps": [
      "Ejecutar análisis de cobertura de código",
      "Identificar áreas sin cobertura",
      "Crear tests para áreas sin cobertura",
      "Ejecutar tests y verificar cobertura",
      "Asegurar que cobertura es al menos 80%",
      "Documentar cobertura actual",
      "Configurar CI para verificar cobertura"
    ],
    "passes": true
  },
  {
    "category": "integration",
    "description": "Agregar integración con CI/CD para validar contratos automáticamente",
    "steps": [
      "Crear script de validación para CI",
      "Validar que el contrato está actualizado",
      "Validar que el contrato es JSON válido",
      "Validar schemas generados",
      "Fallar build si hay problemas",
      "Probar en pipeline de CI",
      "Verificar que la validación funciona correctamente"
    ],
    "passes": true
  },
  {
    "category": "integration",
    "description": "Crear workflows de GitHub Actions para tests y validación",
    "steps": [
      "Crear workflow .github/workflows/tests.yml",
      "Configurar tests en múltiples versiones de PHP",
      "Configurar tests en múltiples versiones de Laravel",
      "Agregar validación de código (Pint, PHPStan)",
      "Agregar validación de contratos",
      "Probar workflow en PR",
      "Verificar que todos los checks pasan"
    ],
    "passes": true
  },
  {
    "category": "integration",
    "description": "Agregar hooks de pre-commit para validar contratos antes de commit",
    "steps": [
      "Crear script de pre-commit",
      "Validar que el contrato está actualizado",
      "Validar formato del contrato",
      "Prevenir commit si hay problemas",
      "Probar hook localmente",
      "Verificar que previene commits inválidos",
      "Documentar cómo usar el hook"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Mejorar README con más ejemplos y casos de uso",
    "steps": [
      "Revisar README actual",
      "Agregar más ejemplos de uso de herramientas MCP",
      "Agregar ejemplos de configuración",
      "Agregar casos de uso comunes",
      "Agregar screenshots o diagramas si es apropiado",
      "Revisar y mejorar formato",
      "Verificar que todos los ejemplos son correctos"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Generar documentación de API para todas las clases públicas",
    "steps": [
      "Revisar todas las clases públicas",
      "Asegurar que todas tienen PHPDoc completo",
      "Generar documentación usando herramienta (phpDocumentor, etc.)",
      "Publicar documentación en GitHub Pages o similar",
      "Agregar enlace a documentación en README",
      "Verificar que la documentación es completa",
      "Actualizar documentación con cada release"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Agregar ejemplos de código en documentación",
    "steps": [
      "Identificar secciones que necesitan ejemplos",
      "Crear ejemplos de uso de cada herramienta MCP",
      "Crear ejemplos de configuración",
      "Crear ejemplos de extensión del paquete",
      "Incluir ejemplos en README y documentación",
      "Verificar que los ejemplos son correctos y funcionan",
      "Probar todos los ejemplos"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Crear guía de troubleshooting para problemas comunes",
    "steps": [
      "Identificar problemas comunes reportados",
      "Crear sección de troubleshooting en README",
      "Documentar soluciones para cada problema",
      "Incluir comandos útiles para debugging",
      "Agregar enlaces a issues relacionados",
      "Revisar y mejorar guía",
      "Actualizar guía cuando surjan nuevos problemas"
    ],
    "passes": false
  },
  {
    "category": "technical",
    "description": "Crear guía de migración para actualizaciones del paquete",
    "steps": [
      "Documentar cambios breaking entre versiones",
      "Crear guía de migración para cada versión mayor",
      "Incluir pasos de migración específicos",
      "Incluir ejemplos de código antes/después",
      "Agregar guía en CHANGELOG o documento separado",
      "Revisar y mejorar guía",
      "Probar pasos de migración"
    ],
    "passes": false
  },
  {
    "category": "technical",
    "description": "Mejorar guía de contribución con estándares de código",
    "steps": [
      "Revisar CONTRIBUTING.md actual",
      "Agregar estándares de código (PSR-12)",
      "Agregar guía de commits (conventional commits)",
      "Agregar proceso de PR",
      "Agregar guía de tests",
      "Revisar y mejorar guía",
      "Asegurar que la guía es clara y completa"
    ],
    "passes": false
  },
  {
    "category": "technical",
    "description": "Automatizar generación de CHANGELOG desde commits",
    "steps": [
      "Configurar herramienta de generación de CHANGELOG",
      "Usar conventional commits para categorizar cambios",
      "Generar CHANGELOG automáticamente en CI",
      "Incluir en proceso de release",
      "Probar generación de CHANGELOG",
      "Verificar que el formato es correcto",
      "Documentar proceso"
    ],
    "passes": false
  },
  {
    "category": "technical",
    "description": "Agregar configuración de PHPStan con nivel alto",
    "steps": [
      "Crear phpstan.neon con nivel 8 o superior",
      "Configurar paths a analizar",
      "Agregar extensiones necesarias",
      "Configurar ignoreErrors para casos conocidos",
      "Ejecutar PHPStan y corregir errores",
      "Agregar PHPStan a CI",
      "Verificar que pasa en CI"
    ],
    "passes": false
  },
  {
    "category": "technical",
    "description": "Agregar configuración de Rector para mejoras automáticas de código",
    "steps": [
      "Crear rector.php con sets apropiados",
      "Configurar reglas de Rector",
      "Ejecutar Rector y revisar cambios",
      "Agregar Rector a CI",
      "Documentar cómo usar Rector",
      "Verificar que Rector mejora el código",
      "Incluir en proceso de desarrollo"
    ],
    "passes": false
  },
  {
    "category": "technical",
    "description": "Aumentar cobertura de tipos en todo el código",
    "steps": [
      "Revisar código para type hints faltantes",
      "Agregar type hints a parámetros",
      "Agregar type hints a retornos",
      "Agregar type hints a propiedades",
      "Usar tipos estrictos (declare(strict_types=1))",
      "Ejecutar PHPStan y corregir errores de tipos",
      "Verificar que todo el código tiene tipos"
    ],
    "passes": false
  },
  {
    "category": "technical",
    "description": "Agregar type hints de retorno a todos los métodos",
    "steps": [
      "Identificar métodos sin return type",
      "Agregar return types a todos los métodos",
      "Usar union types cuando sea apropiado",
      "Usar tipos nullable cuando sea necesario",
      "Ejecutar PHPStan y verificar",
      "Ejecutar tests y verificar que pasan",
      "Documentar decisiones de tipos complejos"
    ],
    "passes": false
  },
  {
    "category": "technical",
    "description": "Agregar type hints a todas las propiedades de clase",
    "steps": [
      "Identificar propiedades sin type hints",
      "Agregar type hints a todas las propiedades",
      "Usar tipos nullable cuando sea necesario",
      "Usar tipos de unión cuando sea apropiado",
      "Ejecutar PHPStan y verificar",
      "Ejecutar tests y verificar que pasan",
      "Documentar propiedades complejas"
    ],
    "passes": false
  },
  {
    "category": "technical",
    "description": "Mejorar PHPDoc en todas las clases y métodos",
    "steps": [
      "Revisar todas las clases y métodos",
      "Agregar PHPDoc completo a clases",
      "Agregar PHPDoc completo a métodos",
      "Incluir @param, @return, @throws cuando sea apropiado",
      "Incluir descripciones claras",
      "Ejecutar phpDocumentor y verificar",
      "Verificar que la documentación es útil"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Documentar arquitectura del paquete y decisiones de diseño",
    "steps": [
      "Crear documento ARCHITECTURE.md",
      "Documentar estructura del paquete",
      "Documentar decisiones de diseño importantes",
      "Documentar flujo de datos",
      "Incluir diagramas si es apropiado",
      "Revisar y mejorar documentación",
      "Mantener documentación actualizada"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Documentar consideraciones de rendimiento y optimizaciones",
    "steps": [
      "Crear documento PERFORMANCE.md",
      "Documentar optimizaciones implementadas",
      "Documentar consideraciones de rendimiento",
      "Incluir benchmarks cuando sea apropiado",
      "Documentar cómo mejorar rendimiento",
      "Revisar y mejorar documentación",
      "Actualizar con nuevas optimizaciones"
    ],
    "passes": true
  },
  {
    "category": "technical",
    "description": "Documentar cómo extender el paquete con analizadores personalizados",
    "steps": [
      "Crear documento EXTENDING.md",
      "Documentar interfaces de analizadores",
      "Crear ejemplo de analizador personalizado",
      "Documentar proceso de registro de analizadores",
      "Incluir ejemplos de código",
      "Revisar y mejorar documentación",
      "Probar ejemplos y verificar que funcionan"
    ],
    "passes": true
  }
]
